"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[3384],{3426:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(5893),i=a(1151);a(4866),a(5162);const r={title:"Middleware - INTERX",sidebar_position:2,slug:"/8a93bc9c-ce24-4129-96d5-9bbe381f6851"},s=void 0,o={id:"What-is-KIRA/Middleware---INTERX",title:"Middleware - INTERX",description:"Overview",source:"@site/tabs/Learn/What-is-KIRA/Middleware---INTERX.mdx",sourceDirName:"What-is-KIRA",slug:"/8a93bc9c-ce24-4129-96d5-9bbe381f6851",permalink:"/docs.kira.network/8a93bc9c-ce24-4129-96d5-9bbe381f6851",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Middleware - INTERX",sidebar_position:2,slug:"/8a93bc9c-ce24-4129-96d5-9bbe381f6851"},sidebar:"defaultSidebar",previous:{title:"Governance",permalink:"/docs.kira.network/aa3b3aee-8e8d-4c5d-bb2c-3f4bf2462afa"},next:{title:"Frontend - MIRO",permalink:"/docs.kira.network/b5188aa1-563f-45e3-906a-9d71b80bd47a"}},l={},c=[{value:"Overview",id:"eb2dd95b428040f69624153b50823d71",level:2},{value:"Kira\u2019s Approach to Data Availability",id:"3c497e92703a473c871d03e7972516cf",level:3},{value:"Decentralized Api Gateway Through Swarm Request",id:"64165f6d3db54be68a8aa002dfb06fa1",level:2}];function d(e){const t={h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"eb2dd95b428040f69624153b50823d71",children:"Overview"}),"\n",(0,n.jsx)(t.p,{children:"INTERX (\u30a4\u30f3\u30bf\u30fc\u30a8\u30c3\u30af\u30b9) is KIRA's decentralized middleware service and is often referred to as KIRA\u2019s Content Availability Layer. It is responsible for node monitoring, peer discovery, response caching, proxy, load balancing, storage, sequencing, and propagation (targeted gossiping) of data and transactions between client-facing applications and KIRA\u2019s back-end services such as L2 apps or SEKAI. It optimizes communication across users, nodes, and Rollapps by enabling the formation of well-connected network subnets dedicated to each application."}),"\n",(0,n.jsx)(t.p,{children:"INTERX simplifies the transition from Web2 to Web3 for developers by removing the complexity of blockchain interactions. Web3 interactions often involve dealing with smart contracts and complex interfaces that must be queried and interpreted like Ethereum's ABI or decoded like SCALE encoded metadata for Substrate RPC, an overwhelming and cumbersome change from the straightforward API calls typical for Web2 environments. By offering a familiar Web2-like API interface and acting as the default 'Sequencer' for applications, INTERX reduces the learning curve of Web3, empowering developers to focus more on their business logic."}),"\n",(0,n.jsx)(t.p,{children:"One of INTERX's most important features is its combination of digital signatures and fraud proofs to effectively function as a decentralized API. This feature eliminates the need for light client implementations and maintenance, as well as dependence on centralized SSL certificate authorities."}),"\n",(0,n.jsx)(t.h3,{id:"3c497e92703a473c871d03e7972516cf",children:"Kira\u2019s Approach to Data Availability"}),"\n",(0,n.jsx)(t.p,{children:"Traditional systems often treat all application data uniformly\u2014both user balances and arbitrary data\u2014 a method that compromises UX and practicality. This is particularly true when quick access to essential and trusted information, like user balances, is required during unexpected interruptions in the application\u2019s sequencing process (e.g. requests rate limiting). KIRA addresses this by clearly distinguishing these types of data. Specifically, user balances can be directly settled on SEKAI, KIRA\u2019s base layer, leveraging account abstraction. This arrangement allows Layer 2 applications to be treated similarly to user accounts, enabling them to perform on-chain actions such as issuing tokens, participating in governance, staking, and even communicating with other applications as if they were autonomous humans."}),"\n",(0,n.jsx)(t.p,{children:"In managing and ensuring the availability of arbitrary application data, INTERX adopts a specialized implementation designed to enhance the data replication versus network overhead ratio. This implementation is underpinned by four foundational concepts:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Integrated Data Management:"})," Consensus nodes operate and autoscale INTERX containers alongside their RollApp execution containers, akin to how edge nodes function within traditional Web2 networks. An edge node serves as a conduit between local environments (SEKAI and RollApp containers in KIRA\u2019s case) and the external world. In this setup, essential data is directly accessible on the same devices that execute the application, thus reducing latency and the dependency issues seen when DA is handled by an external network."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Dedicated DA Sub-networks"}),": Leveraging its node discovery capabilities, INTERX assigns each RollApp its own firewalled and rate-limited DA 'subnet'. This architecture optimizes bandwidth utilization and resource allocation by reducing the exchange and management of the application\u2019s data only to the nodes directly relevant to the application\u2014namely, its executors and verifiers."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Adaptive Data Replication"}),": Traditional DA systems often employ a one-size-fits-all replication factor. Essentially, they define the level of redundancy through a fixed number of copies distributed within the network to ensure data availability. In practice, however, individual applications have distinct requirements for data access speed and replication based on the data type. With INTERX, RollApp data is replicated based on the individual needs of executors and verifiers. Developers can scale this replication level to align precisely with their application's needs, such as minimum bandwidth utilization for noncritical data and/or maximum possible security for application-critical data."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Caching:"})," INTERX implements a caching mechanism to efficiently manage high-demand scenarios and prevent system overload. This feature is especially important in KIRA, where SEKAI\u2019s block time can be extended based on the number of consensus nodes involved, influencing the likelihood of data being queried multiple times before any updates occur. By storing data after its initial retrieval, INTERX can swiftly respond to duplicate requests, conserving resources required to perform complex queries and thus maintaining network responsiveness."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"64165f6d3db54be68a8aa002dfb06fa1",children:"Decentralized Api Gateway Through Swarm Request"}),"\n",(0,n.jsx)(t.p,{children:"A distinctive feature of INTERX is its functionality as a decentralized RPC gateway. This capability stems from its unique setup where each INTERX node, regardless of its associated subnet, is linked to a KIRA account address, with all responses being digitally signed. This architecture allows users to query multiple nodes simultaneously and evaluate the responses against each other. Such a mechanism enables users to identify nodes that consistently deliver precise responses and craft off-chain fraud proofs against nodes disseminating fraudulent or inconsistent data."}),"\n",(0,n.jsx)(t.p,{children:"While light clients theoretically offer higher security through block-by-block consensus verification (without storing data), they fall short due to the maintenance they require. This maintenance challenge becomes particularly pronounced across hundreds or thousands of applications in a growing multi-chain world. By enabling the creation of fraud proofs, INTERX introduces a practical alternative for decentralization. It establishes a balance between the security offered by light clients and the convenience of Infura-style RPC providers. Through repeated queries to a broad spectrum of INTERX nodes, users can achieve a level of security comparable to that of light clients, assuming these nodes are either verified through the Identity Registrar or have stakes involved. This system underscores that even a single honest INTERX node in the query batch can trigger the eviction or slashing of dishonest ones. However, for maximum safety, users are recommended to operate their own INTERX node as well as a SEKAI instance, essentially running a full node."})]})}function u(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},5162:(e,t,a)=>{a.d(t,{Z:()=>s});a(7294);var n=a(6905);const i={tabItem:"tabItem_Ymn6"};var r=a(5893);function s(e){let{children:t,hidden:a,className:s}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,n.Z)(i.tabItem,s),hidden:a,children:t})}},4866:(e,t,a)=>{a.d(t,{Z:()=>x});var n=a(7294),i=a(6905),r=a(2466),s=a(6550),o=a(469),l=a(1980),c=a(7392),d=a(12);function u(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:i}}=e;return{value:t,label:a,attributes:n,default:i}}))}(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function p(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:a}=e;const i=(0,s.k6)(),r=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l._X)(r),(0,n.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(i.location.search);t.set(r,e),i.replace({...i.location,search:t.toString()})}),[r,i])]}function b(e){const{defaultValue:t,queryString:a=!1,groupId:i}=e,r=h(e),[s,l]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[c,u]=f({queryString:a,groupId:i}),[b,m]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,r]=(0,d.Nk)(a);return[i,(0,n.useCallback)((e=>{a&&r.set(e)}),[a,r])]}({groupId:i}),g=(()=>{const e=c??b;return p({value:e,tabValues:r})?e:null})();(0,o.Z)((()=>{g&&l(g)}),[g]);return{selectedValue:s,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),m(e)}),[u,m,r]),tabValues:r}}var m=a(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=a(5893);function y(e){let{className:t,block:a,selectedValue:n,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.o5)(),d=e=>{const t=e.currentTarget,a=l.indexOf(t),i=o[a].value;i!==n&&(c(t),s(i))},u=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;t=l[a]??l[0];break}case"ArrowLeft":{const a=l.indexOf(e.currentTarget)-1;t=l[a]??l[l.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},t),children:o.map((e=>{let{value:t,label:a,attributes:r}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>l.push(e),onKeyDown:u,onClick:d,...r,className:(0,i.Z)("tabs__item",g.tabItem,r?.className,{"tabs__item--active":n===t}),children:a??t},t)}))})}function w(e){let{lazy:t,children:a,selectedValue:i}=e;const r=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===i));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==i})))})}function I(e){const t=b(e);return(0,v.jsxs)("div",{className:(0,i.Z)("tabs-container",g.tabList),children:[(0,v.jsx)(y,{...e,...t}),(0,v.jsx)(w,{...e,...t})]})}function x(e){const t=(0,m.Z)();return(0,v.jsx)(I,{...e,children:u(e.children)},String(t))}},1151:(e,t,a)=>{a.d(t,{Z:()=>o,a:()=>s});var n=a(7294);const i={},r=n.createContext(i);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);