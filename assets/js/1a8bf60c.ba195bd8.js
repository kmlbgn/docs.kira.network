"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[4272],{3354:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(5893),i=n(1151);n(4866),n(5162);const o={title:"Overview",sidebar_position:0,slug:"/9a5aaea6-1b50-41fe-9c54-cd035a26d0a5"},r=void 0,s={id:"What-is-KIRA/Layer-2/Overview",title:"Overview",description:"KIRA\u2019s base layer (SEKAI) handles governance, token transfers, multi-staking, and all other system security-related on-chain logic. At the same time, SEKAI assists in the execution of decentralized applications taking place on their dedicated off-chain subnets by enabling their orchestration, communication, and settlement. This separation enables parallel scaling of execution, storage, and networking capabilities of each application. KIRA applications, also known as RollApps, consist of an execution container defining application logic, and a verification container defining how changes in an application state can be verified.",source:"@site/tabs/learn/What-is-KIRA/Layer-2/Overview.mdx",sourceDirName:"What-is-KIRA/Layer-2",slug:"/9a5aaea6-1b50-41fe-9c54-cd035a26d0a5",permalink:"/docs.kira.network/9a5aaea6-1b50-41fe-9c54-cd035a26d0a5",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Overview",sidebar_position:0,slug:"/9a5aaea6-1b50-41fe-9c54-cd035a26d0a5"},sidebar:"defaultSidebar",previous:{title:"Orchestrator - RYOKAI",permalink:"/docs.kira.network/2ac3bfb7-478c-4207-a290-051d9fa6124f"},next:{title:"Virtual Finality Gadget",permalink:"/docs.kira.network/bba461ae-7c67-4b66-8f1b-c51c887f2671"}},l={},c=[{value:"Application Submission",id:"4b45b29d9f7147f69322eab08f6c271c",level:2},{value:"Permissioned Execution, Permissionless Verification",id:"63a067c5526f4b7eb220c71b554da361",level:2},{value:"Sessions",id:"08087f31d2204472be584c32733b9a2f",level:2}];function u(e){const t={a:"a",admonition:"admonition",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"KIRA\u2019s base layer (SEKAI) handles governance, token transfers, multi-staking, and all other system security-related on-chain logic. At the same time, SEKAI assists in the execution of decentralized applications taking place on their dedicated off-chain subnets by enabling their orchestration, communication, and settlement. This separation enables parallel scaling of execution, storage, and networking capabilities of each application. KIRA applications, also known as RollApps, consist of an execution container defining application logic, and a verification container defining how changes in an application state can be verified."}),"\n",(0,a.jsx)(t.p,{children:"KIRA by default pessimistically assumes incorrectness of all L2 computations. It only allows for application state settlement if the developer-programmable consensus of nodes verifies the application execution. This is in contrast to optimistic rollup systems which by default assume the correctness of all computations unless fraud proofs are presented which unnecessarily prolong the settlement process even if all network participants agree that the application state transitions are correct."}),"\n",(0,a.jsx)(t.h2,{id:"4b45b29d9f7147f69322eab08f6c271c",children:"Application Submission"}),"\n",(0,a.jsx)(t.p,{children:"Before a dApp can be deployed on the KIRA network, it must go through an on-chain governance proposal process. This prevents spam applications and ineffective code from launching. The proposal is submitted by controllers; this proposal also signals the requirements for running the application. A minimum bond in KEX tokens is required to raise the proposal, ensuring developer commitment. A minimum bond must also be reached before the proposal duration ends for the application to be accepted. The minimum bond can be crowdsourced across collaborators. If it is not reached before the end of the proposal period, the dApp is rejected and bonds are returned. There is also a maximum bond that caps total deposits. Once approved through governance, dApp tokens representing ownership are minted and paired with the bonded KEX in a v2 Uniswap pool."}),"\n",(0,a.jsx)(t.p,{children:"This permissionless, crowdsourced process is similar to Polkadot parachain auctions. However, the bonded KEX crowdsourced through the proposal remain liquid: Upon approval, dApp tokens representing ownership are minted and paired with the bonded KEX in a Uniswap v2-like pool and the LP tokens are distributed to all investors who contributed to crowdsource."}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["More information about the crowdsourcing mechanism is described in ",(0,a.jsx)(t.a,{href:"/a6a660a6-3e5c-4a53-9ec3-14aa07f00351",children:"Initial Liquidity Offering "}),"page."]})}),"\n",(0,a.jsx)(t.h2,{id:"63a067c5526f4b7eb220c71b554da361",children:"Permissioned Execution, Permissionless Verification"}),"\n",(0,a.jsx)(t.p,{children:"There are two primary roles for participation in a RollApp execution process - Executors and Verifiers, also referred to as Fishermen."}),"\n",(0,a.jsx)(t.p,{children:"KIRA\u2019s Validators have the option to take on either or both of these roles, they are not compelled and do not need to post a bond to take these roles. This is to ensure they can adapt their hardware to suit the application's needs and avoid running content that may pose legal issues in their operating region. However their participation is subject to approval by controllers (application owners), and they can be evicted from SEKAI validator set if acting maliciously. If a validator becomes an Executor, they will run the execution container and serve as Leader for Sessions, proposing state changes while also automatically taking on the role of Verifier when not actively leading a Session."}),"\n",(0,a.jsx)(t.p,{children:"Any users can permissionlessly become Fishermen, i.e. if they have vested interest in this application. They are not subject to approval by controllers, but must submit a bond in the dApp's liquidity pool tokens. The bond amount is set via governance, defaulting to 0.1% of the pool\u2019s total LP tokens circulating supply. In summary, validators can opt-in to run as Executors or Verifiers, pending approval. Other users can freely become Fishermen verifiers by providing a bond."}),"\n",(0,a.jsx)(t.p,{children:"The key difference between the Executor and Verifier lies in their responsibilities and how each role is held accountable. Only Executors can become Leaders and propose state changes for an application, while Fishermen solely verify its integrity. Executors are held accountable by risking their validation role and income if removed for misconduct. Fishermen are accountable through the verifier bond they post in tokens, which can be slashed for faulty verification."}),"\n",(0,a.jsx)(t.h2,{id:"08087f31d2204472be584c32733b9a2f",children:"Sessions"}),"\n",(0,a.jsx)(t.p,{children:'In KIRA\'s Layer 2, computation occurs in timed periods called Sessions, similar to the "challenge periods" in Ethereum optimistic rollups. However, unlike Ethereum rollups which optimistically assume correct execution, KIRA pessimistically assumes incorrect results, and only settles state if sufficient verifications occur in a given Session.'}),"\n",(0,a.jsx)(t.p,{children:"A session proceeds as follows:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"A single Executor acts as the Session leader and performs computation, proposing a new application state root  (the hash of the new app database state) and account balances changes on SEKAI. The leader can only be an active validator and is chosen in equal round-robin fashion among existing application\u2019s Executors."}),"\n",(0,a.jsx)(t.li,{children:"Immediately after the current Executor finishes execution, the next leader optimistically start executing its own session. This mechanism allows for continuous execution without waiting for the prior session's full verification to complete. In rare scenarios where a session was skipped (i.e. Leader timed out) and the following one was not properly executed, both sessions can be discarded, although this is unlikely to occur."}),"\n",(0,a.jsx)(t.li,{children:"Other Executors act as Verifier and collect the leader results and cast their approval on proposed state changes. The end of the session and settlement requires over 2/3 Executor participation and unanimous agreement. In cases where the application has only one Executor, the end of the session relies on the approval of no less than 2/3 of all active Verifiers."}),"\n",(0,a.jsx)(t.li,{children:"Meanwhile multiple verifier nodes (Fishermen) verify integrity of the leader's execution. They can halt settlement if they find incorrect state transitions, but cannot finalize settlement, only Executors can."}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"The number of Verifiers (fishermen) is uncapped and can be much greater than the number of Executors. However, there is only one Leader at any point in time,"})})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},5162:(e,t,n)=>{n.d(t,{Z:()=>r});n(7294);var a=n(6905);const i={tabItem:"tabItem_Ymn6"};var o=n(5893);function r(e){let{children:t,hidden:n,className:r}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.Z)(i.tabItem,r),hidden:n,children:t})}},4866:(e,t,n)=>{n.d(t,{Z:()=>k});var a=n(7294),i=n(6905),o=n(2466),r=n(6550),s=n(469),l=n(1980),c=n(7392),u=n(12);function d(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:i}}=e;return{value:t,label:n,attributes:a,default:i}}))}(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const i=(0,r.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(o),(0,a.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(i.location.search);t.set(o,e),i.replace({...i.location,search:t.toString()})}),[o,i])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:i}=e,o=p(e),[r,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:o}))),[c,d]=f({queryString:n,groupId:i}),[m,b]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,o]=(0,u.Nk)(n);return[i,(0,a.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:i}),v=(()=>{const e=c??m;return h({value:e,tabValues:o})?e:null})();(0,s.Z)((()=>{v&&l(v)}),[v]);return{selectedValue:r,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),b(e)}),[d,b,o]),tabValues:o}}var b=n(2389);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=n(5893);function y(e){let{className:t,block:n,selectedValue:a,selectValue:r,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),u=e=>{const t=e.currentTarget,n=l.indexOf(t),i=s[n].value;i!==a&&(c(t),r(i))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t),children:s.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>l.push(e),onKeyDown:d,onClick:u,...o,className:(0,i.Z)("tabs__item",v.tabItem,o?.className,{"tabs__item--active":a===t}),children:n??t},t)}))})}function w(e){let{lazy:t,children:n,selectedValue:i}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==i})))})}function x(e){const t=m(e);return(0,g.jsxs)("div",{className:(0,i.Z)("tabs-container",v.tabList),children:[(0,g.jsx)(y,{...e,...t}),(0,g.jsx)(w,{...e,...t})]})}function k(e){const t=(0,b.Z)();return(0,g.jsx)(x,{...e,children:d(e.children)},String(t))}},1151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>r});var a=n(7294);const i={},o=a.createContext(i);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);